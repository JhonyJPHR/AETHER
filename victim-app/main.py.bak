# victim-app/main.py
import logging
import sys
from fastapi import FastAPI, HTTPException

# Aumenta o limite de recursão para o erro explodir mais rápido
sys.setrecursionlimit(1000)

logging.basicConfig(
    filename='../shared_logs/app.log',
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)

app = FastAPI(title="ChaosBank API - Target System")

@app.get("/")
def read_root():
    return {"status": "active", "system": "ChaosBank"}

# --- A ARMADILHA MORTAL ---
def calculate_compound_interest(amount):
    """
    Função perigosa: Ela chama a si mesma sem condição de parada.
    Isso causa um Stack Overflow (RecursionError).
    """
    logging.info(f"Calculando juros para: {amount}")
    # BUG: Não tem 'if amount > x: return'. Vai rodar para sempre.
    return amount + calculate_compound_interest(amount * 1.01)

@app.get("/investment/{amount}")
def simulate_investment(amount: float):
    logging.info(f"Iniciando simulação de investimento: ${amount}")
    
    try:
        # Chama a função recursiva mortal
        final_value = calculate_compound_interest(amount)
        
        return {"original": amount, "final": final_value}

    except RecursionError:
        # Capturamos o erro específico de estouro de pilha
        error_msg = "CRITICAL_FAILURE: RecursionError detected - Stack Overflow in calculate_compound_interest"
        logging.error(error_msg)
        raise HTTPException(status_code=500, detail="Calculation Engine Crashed")
    
    except Exception as e:
        error_msg = f"CRITICAL_FAILURE: {str(e)}"
        logging.error(error_msg)
        raise HTTPException(status_code=500, detail="Internal Server Error")